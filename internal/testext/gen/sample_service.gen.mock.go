// Code generated by Abide - DO NOT EDIT.
//
//	Timestamp: Mon, 03 Jul 2023 13:40:55 EDT
//	Source:    sample_service.go
//	Generator: https://github.com/monadicstack/abide
package testext

import (
	"context"
	"fmt"
	"time"

	"github.com/monadicstack/abide/internal/testext"
)

// MockSampleService allows you to program behaviors into a mock instance of SampleService. You supply
// dynamic functions named "XxxFunc" to provide the custom behavior; so if your service has a function
// called 'CreateUser', you supply a function for 'CreateUserFunc'.
//
// You do not need to supply behaviors for every single service function; just the ones you plan to
// test. If you do invoke a function without a programmed behavior, it will just return an error
// with a message indicating that it wasn't implemented.
type MockSampleService struct {
	AuthorizationFunc     func(context.Context, *testext.SampleRequest) (*testext.SampleResponse, error)
	ComplexValuesFunc     func(context.Context, *testext.SampleComplexRequest) (*testext.SampleComplexResponse, error)
	ComplexValuesPathFunc func(context.Context, *testext.SampleComplexRequest) (*testext.SampleComplexResponse, error)
	CustomRouteFunc       func(context.Context, *testext.SampleRequest) (*testext.SampleResponse, error)
	CustomRouteBodyFunc   func(context.Context, *testext.SampleRequest) (*testext.SampleResponse, error)
	CustomRouteQueryFunc  func(context.Context, *testext.SampleRequest) (*testext.SampleResponse, error)
	DefaultsFunc          func(context.Context, *testext.SampleRequest) (*testext.SampleResponse, error)
	DownloadFunc          func(context.Context, *testext.SampleDownloadRequest) (*testext.SampleDownloadResponse, error)
	DownloadResumableFunc func(context.Context, *testext.SampleDownloadRequest) (*testext.SampleDownloadResponse, error)
	Fail4XXFunc           func(context.Context, *testext.SampleRequest) (*testext.SampleResponse, error)
	Fail5XXFunc           func(context.Context, *testext.SampleRequest) (*testext.SampleResponse, error)
	ListenerAFunc         func(context.Context, *testext.SampleRequest) (*testext.SampleResponse, error)
	ListenerBFunc         func(context.Context, *testext.SampleRequest) (*testext.SampleResponse, error)
	OmitMeFunc            func(context.Context, *testext.SampleRequest) (*testext.SampleResponse, error)
	RedirectFunc          func(context.Context, *testext.SampleRedirectRequest) (*testext.SampleRedirectResponse, error)
	SecureWithRolesFunc   func(context.Context, *testext.SampleSecurityRequest) (*testext.SampleSecurityResponse, error)
	SleepFunc             func(context.Context, *testext.SampleRequest) (*testext.SampleResponse, error)
	TriggerFailureFunc    func(context.Context, *testext.SampleRequest) (*testext.SampleResponse, error)
	TriggerLowerCaseFunc  func(context.Context, *testext.SampleRequest) (*testext.SampleResponse, error)
	TriggerUpperCaseFunc  func(context.Context, *testext.SampleRequest) (*testext.SampleResponse, error)

	Calls struct {
		Authorization     callsSampleServiceAuthorization
		ComplexValues     callsSampleServiceComplexValues
		ComplexValuesPath callsSampleServiceComplexValuesPath
		CustomRoute       callsSampleServiceCustomRoute
		CustomRouteBody   callsSampleServiceCustomRouteBody
		CustomRouteQuery  callsSampleServiceCustomRouteQuery
		Defaults          callsSampleServiceDefaults
		Download          callsSampleServiceDownload
		DownloadResumable callsSampleServiceDownloadResumable
		Fail4XX           callsSampleServiceFail4XX
		Fail5XX           callsSampleServiceFail5XX
		ListenerA         callsSampleServiceListenerA
		ListenerB         callsSampleServiceListenerB
		OmitMe            callsSampleServiceOmitMe
		Redirect          callsSampleServiceRedirect
		SecureWithRoles   callsSampleServiceSecureWithRoles
		Sleep             callsSampleServiceSleep
		TriggerFailure    callsSampleServiceTriggerFailure
		TriggerLowerCase  callsSampleServiceTriggerLowerCase
		TriggerUpperCase  callsSampleServiceTriggerUpperCase
	}
}

/* ---- SampleService.Authorization Mock Support For  ---- */

func (mock *MockSampleService) Authorization(ctx context.Context, request *testext.SampleRequest) (*testext.SampleResponse, error) {
	mock.Calls.Authorization = mock.Calls.Authorization.invoked(*request)
	if mock.AuthorizationFunc == nil {
		return nil, fmt.Errorf("SampleService.Authorization not implemented")
	}
	response, err := mock.AuthorizationFunc(ctx, request)
	return response, err
}

type callSampleServiceAuthorization struct {
	Time    time.Time
	Request testext.SampleRequest
}

type callsSampleServiceAuthorization []callSampleServiceAuthorization

func (calls callsSampleServiceAuthorization) invoked(request testext.SampleRequest) callsSampleServiceAuthorization {
	return append(calls, callSampleServiceAuthorization{Time: time.Now(), Request: request})
}

// Times return the total number of times that Authorization was invoked with any request arguments.
func (calls callsSampleServiceAuthorization) Times() int {
	return len(calls)
}

// TimesFor return the total number of times that Authorization was invoked with the specific input. Equality
// is determined using == on this 'request' param and the de-referenced one used in the invocation, so
// we'll only county times for those with structural equality.
func (calls callsSampleServiceAuthorization) TimesFor(request testext.SampleRequest) int {
	return calls.TimesMatching(func(actual testext.SampleRequest) bool {
		return actual == request
	})
}

// TimesMatching return the total number of times that Authorization was invoked with any
// input that returns true when fed to your predicate function. It's a way to filter by
// requests that meet some requirement more complex than equality (like TimesFor uses).
func (calls callsSampleServiceAuthorization) TimesMatching(pred func(testext.SampleRequest) bool) int {
	count := 0
	for _, call := range calls {
		if pred(call.Request) {
			count++
		}
	}
	return count
}

/* ---- SampleService.ComplexValues Mock Support For  ---- */

func (mock *MockSampleService) ComplexValues(ctx context.Context, request *testext.SampleComplexRequest) (*testext.SampleComplexResponse, error) {
	mock.Calls.ComplexValues = mock.Calls.ComplexValues.invoked(*request)
	if mock.ComplexValuesFunc == nil {
		return nil, fmt.Errorf("SampleService.ComplexValues not implemented")
	}
	response, err := mock.ComplexValuesFunc(ctx, request)
	return response, err
}

type callSampleServiceComplexValues struct {
	Time    time.Time
	Request testext.SampleComplexRequest
}

type callsSampleServiceComplexValues []callSampleServiceComplexValues

func (calls callsSampleServiceComplexValues) invoked(request testext.SampleComplexRequest) callsSampleServiceComplexValues {
	return append(calls, callSampleServiceComplexValues{Time: time.Now(), Request: request})
}

// Times return the total number of times that ComplexValues was invoked with any request arguments.
func (calls callsSampleServiceComplexValues) Times() int {
	return len(calls)
}

// TimesFor return the total number of times that ComplexValues was invoked with the specific input. Equality
// is determined using == on this 'request' param and the de-referenced one used in the invocation, so
// we'll only county times for those with structural equality.
func (calls callsSampleServiceComplexValues) TimesFor(request testext.SampleComplexRequest) int {
	return calls.TimesMatching(func(actual testext.SampleComplexRequest) bool {
		return actual == request
	})
}

// TimesMatching return the total number of times that ComplexValues was invoked with any
// input that returns true when fed to your predicate function. It's a way to filter by
// requests that meet some requirement more complex than equality (like TimesFor uses).
func (calls callsSampleServiceComplexValues) TimesMatching(pred func(testext.SampleComplexRequest) bool) int {
	count := 0
	for _, call := range calls {
		if pred(call.Request) {
			count++
		}
	}
	return count
}

/* ---- SampleService.ComplexValuesPath Mock Support For  ---- */

func (mock *MockSampleService) ComplexValuesPath(ctx context.Context, request *testext.SampleComplexRequest) (*testext.SampleComplexResponse, error) {
	mock.Calls.ComplexValuesPath = mock.Calls.ComplexValuesPath.invoked(*request)
	if mock.ComplexValuesPathFunc == nil {
		return nil, fmt.Errorf("SampleService.ComplexValuesPath not implemented")
	}
	response, err := mock.ComplexValuesPathFunc(ctx, request)
	return response, err
}

type callSampleServiceComplexValuesPath struct {
	Time    time.Time
	Request testext.SampleComplexRequest
}

type callsSampleServiceComplexValuesPath []callSampleServiceComplexValuesPath

func (calls callsSampleServiceComplexValuesPath) invoked(request testext.SampleComplexRequest) callsSampleServiceComplexValuesPath {
	return append(calls, callSampleServiceComplexValuesPath{Time: time.Now(), Request: request})
}

// Times return the total number of times that ComplexValuesPath was invoked with any request arguments.
func (calls callsSampleServiceComplexValuesPath) Times() int {
	return len(calls)
}

// TimesFor return the total number of times that ComplexValuesPath was invoked with the specific input. Equality
// is determined using == on this 'request' param and the de-referenced one used in the invocation, so
// we'll only county times for those with structural equality.
func (calls callsSampleServiceComplexValuesPath) TimesFor(request testext.SampleComplexRequest) int {
	return calls.TimesMatching(func(actual testext.SampleComplexRequest) bool {
		return actual == request
	})
}

// TimesMatching return the total number of times that ComplexValuesPath was invoked with any
// input that returns true when fed to your predicate function. It's a way to filter by
// requests that meet some requirement more complex than equality (like TimesFor uses).
func (calls callsSampleServiceComplexValuesPath) TimesMatching(pred func(testext.SampleComplexRequest) bool) int {
	count := 0
	for _, call := range calls {
		if pred(call.Request) {
			count++
		}
	}
	return count
}

/* ---- SampleService.CustomRoute Mock Support For  ---- */

func (mock *MockSampleService) CustomRoute(ctx context.Context, request *testext.SampleRequest) (*testext.SampleResponse, error) {
	mock.Calls.CustomRoute = mock.Calls.CustomRoute.invoked(*request)
	if mock.CustomRouteFunc == nil {
		return nil, fmt.Errorf("SampleService.CustomRoute not implemented")
	}
	response, err := mock.CustomRouteFunc(ctx, request)
	return response, err
}

type callSampleServiceCustomRoute struct {
	Time    time.Time
	Request testext.SampleRequest
}

type callsSampleServiceCustomRoute []callSampleServiceCustomRoute

func (calls callsSampleServiceCustomRoute) invoked(request testext.SampleRequest) callsSampleServiceCustomRoute {
	return append(calls, callSampleServiceCustomRoute{Time: time.Now(), Request: request})
}

// Times return the total number of times that CustomRoute was invoked with any request arguments.
func (calls callsSampleServiceCustomRoute) Times() int {
	return len(calls)
}

// TimesFor return the total number of times that CustomRoute was invoked with the specific input. Equality
// is determined using == on this 'request' param and the de-referenced one used in the invocation, so
// we'll only county times for those with structural equality.
func (calls callsSampleServiceCustomRoute) TimesFor(request testext.SampleRequest) int {
	return calls.TimesMatching(func(actual testext.SampleRequest) bool {
		return actual == request
	})
}

// TimesMatching return the total number of times that CustomRoute was invoked with any
// input that returns true when fed to your predicate function. It's a way to filter by
// requests that meet some requirement more complex than equality (like TimesFor uses).
func (calls callsSampleServiceCustomRoute) TimesMatching(pred func(testext.SampleRequest) bool) int {
	count := 0
	for _, call := range calls {
		if pred(call.Request) {
			count++
		}
	}
	return count
}

/* ---- SampleService.CustomRouteBody Mock Support For  ---- */

func (mock *MockSampleService) CustomRouteBody(ctx context.Context, request *testext.SampleRequest) (*testext.SampleResponse, error) {
	mock.Calls.CustomRouteBody = mock.Calls.CustomRouteBody.invoked(*request)
	if mock.CustomRouteBodyFunc == nil {
		return nil, fmt.Errorf("SampleService.CustomRouteBody not implemented")
	}
	response, err := mock.CustomRouteBodyFunc(ctx, request)
	return response, err
}

type callSampleServiceCustomRouteBody struct {
	Time    time.Time
	Request testext.SampleRequest
}

type callsSampleServiceCustomRouteBody []callSampleServiceCustomRouteBody

func (calls callsSampleServiceCustomRouteBody) invoked(request testext.SampleRequest) callsSampleServiceCustomRouteBody {
	return append(calls, callSampleServiceCustomRouteBody{Time: time.Now(), Request: request})
}

// Times return the total number of times that CustomRouteBody was invoked with any request arguments.
func (calls callsSampleServiceCustomRouteBody) Times() int {
	return len(calls)
}

// TimesFor return the total number of times that CustomRouteBody was invoked with the specific input. Equality
// is determined using == on this 'request' param and the de-referenced one used in the invocation, so
// we'll only county times for those with structural equality.
func (calls callsSampleServiceCustomRouteBody) TimesFor(request testext.SampleRequest) int {
	return calls.TimesMatching(func(actual testext.SampleRequest) bool {
		return actual == request
	})
}

// TimesMatching return the total number of times that CustomRouteBody was invoked with any
// input that returns true when fed to your predicate function. It's a way to filter by
// requests that meet some requirement more complex than equality (like TimesFor uses).
func (calls callsSampleServiceCustomRouteBody) TimesMatching(pred func(testext.SampleRequest) bool) int {
	count := 0
	for _, call := range calls {
		if pred(call.Request) {
			count++
		}
	}
	return count
}

/* ---- SampleService.CustomRouteQuery Mock Support For  ---- */

func (mock *MockSampleService) CustomRouteQuery(ctx context.Context, request *testext.SampleRequest) (*testext.SampleResponse, error) {
	mock.Calls.CustomRouteQuery = mock.Calls.CustomRouteQuery.invoked(*request)
	if mock.CustomRouteQueryFunc == nil {
		return nil, fmt.Errorf("SampleService.CustomRouteQuery not implemented")
	}
	response, err := mock.CustomRouteQueryFunc(ctx, request)
	return response, err
}

type callSampleServiceCustomRouteQuery struct {
	Time    time.Time
	Request testext.SampleRequest
}

type callsSampleServiceCustomRouteQuery []callSampleServiceCustomRouteQuery

func (calls callsSampleServiceCustomRouteQuery) invoked(request testext.SampleRequest) callsSampleServiceCustomRouteQuery {
	return append(calls, callSampleServiceCustomRouteQuery{Time: time.Now(), Request: request})
}

// Times return the total number of times that CustomRouteQuery was invoked with any request arguments.
func (calls callsSampleServiceCustomRouteQuery) Times() int {
	return len(calls)
}

// TimesFor return the total number of times that CustomRouteQuery was invoked with the specific input. Equality
// is determined using == on this 'request' param and the de-referenced one used in the invocation, so
// we'll only county times for those with structural equality.
func (calls callsSampleServiceCustomRouteQuery) TimesFor(request testext.SampleRequest) int {
	return calls.TimesMatching(func(actual testext.SampleRequest) bool {
		return actual == request
	})
}

// TimesMatching return the total number of times that CustomRouteQuery was invoked with any
// input that returns true when fed to your predicate function. It's a way to filter by
// requests that meet some requirement more complex than equality (like TimesFor uses).
func (calls callsSampleServiceCustomRouteQuery) TimesMatching(pred func(testext.SampleRequest) bool) int {
	count := 0
	for _, call := range calls {
		if pred(call.Request) {
			count++
		}
	}
	return count
}

/* ---- SampleService.Defaults Mock Support For  ---- */

func (mock *MockSampleService) Defaults(ctx context.Context, request *testext.SampleRequest) (*testext.SampleResponse, error) {
	mock.Calls.Defaults = mock.Calls.Defaults.invoked(*request)
	if mock.DefaultsFunc == nil {
		return nil, fmt.Errorf("SampleService.Defaults not implemented")
	}
	response, err := mock.DefaultsFunc(ctx, request)
	return response, err
}

type callSampleServiceDefaults struct {
	Time    time.Time
	Request testext.SampleRequest
}

type callsSampleServiceDefaults []callSampleServiceDefaults

func (calls callsSampleServiceDefaults) invoked(request testext.SampleRequest) callsSampleServiceDefaults {
	return append(calls, callSampleServiceDefaults{Time: time.Now(), Request: request})
}

// Times return the total number of times that Defaults was invoked with any request arguments.
func (calls callsSampleServiceDefaults) Times() int {
	return len(calls)
}

// TimesFor return the total number of times that Defaults was invoked with the specific input. Equality
// is determined using == on this 'request' param and the de-referenced one used in the invocation, so
// we'll only county times for those with structural equality.
func (calls callsSampleServiceDefaults) TimesFor(request testext.SampleRequest) int {
	return calls.TimesMatching(func(actual testext.SampleRequest) bool {
		return actual == request
	})
}

// TimesMatching return the total number of times that Defaults was invoked with any
// input that returns true when fed to your predicate function. It's a way to filter by
// requests that meet some requirement more complex than equality (like TimesFor uses).
func (calls callsSampleServiceDefaults) TimesMatching(pred func(testext.SampleRequest) bool) int {
	count := 0
	for _, call := range calls {
		if pred(call.Request) {
			count++
		}
	}
	return count
}

/* ---- SampleService.Download Mock Support For  ---- */

func (mock *MockSampleService) Download(ctx context.Context, request *testext.SampleDownloadRequest) (*testext.SampleDownloadResponse, error) {
	mock.Calls.Download = mock.Calls.Download.invoked(*request)
	if mock.DownloadFunc == nil {
		return nil, fmt.Errorf("SampleService.Download not implemented")
	}
	response, err := mock.DownloadFunc(ctx, request)
	return response, err
}

type callSampleServiceDownload struct {
	Time    time.Time
	Request testext.SampleDownloadRequest
}

type callsSampleServiceDownload []callSampleServiceDownload

func (calls callsSampleServiceDownload) invoked(request testext.SampleDownloadRequest) callsSampleServiceDownload {
	return append(calls, callSampleServiceDownload{Time: time.Now(), Request: request})
}

// Times return the total number of times that Download was invoked with any request arguments.
func (calls callsSampleServiceDownload) Times() int {
	return len(calls)
}

// TimesFor return the total number of times that Download was invoked with the specific input. Equality
// is determined using == on this 'request' param and the de-referenced one used in the invocation, so
// we'll only county times for those with structural equality.
func (calls callsSampleServiceDownload) TimesFor(request testext.SampleDownloadRequest) int {
	return calls.TimesMatching(func(actual testext.SampleDownloadRequest) bool {
		return actual == request
	})
}

// TimesMatching return the total number of times that Download was invoked with any
// input that returns true when fed to your predicate function. It's a way to filter by
// requests that meet some requirement more complex than equality (like TimesFor uses).
func (calls callsSampleServiceDownload) TimesMatching(pred func(testext.SampleDownloadRequest) bool) int {
	count := 0
	for _, call := range calls {
		if pred(call.Request) {
			count++
		}
	}
	return count
}

/* ---- SampleService.DownloadResumable Mock Support For  ---- */

func (mock *MockSampleService) DownloadResumable(ctx context.Context, request *testext.SampleDownloadRequest) (*testext.SampleDownloadResponse, error) {
	mock.Calls.DownloadResumable = mock.Calls.DownloadResumable.invoked(*request)
	if mock.DownloadResumableFunc == nil {
		return nil, fmt.Errorf("SampleService.DownloadResumable not implemented")
	}
	response, err := mock.DownloadResumableFunc(ctx, request)
	return response, err
}

type callSampleServiceDownloadResumable struct {
	Time    time.Time
	Request testext.SampleDownloadRequest
}

type callsSampleServiceDownloadResumable []callSampleServiceDownloadResumable

func (calls callsSampleServiceDownloadResumable) invoked(request testext.SampleDownloadRequest) callsSampleServiceDownloadResumable {
	return append(calls, callSampleServiceDownloadResumable{Time: time.Now(), Request: request})
}

// Times return the total number of times that DownloadResumable was invoked with any request arguments.
func (calls callsSampleServiceDownloadResumable) Times() int {
	return len(calls)
}

// TimesFor return the total number of times that DownloadResumable was invoked with the specific input. Equality
// is determined using == on this 'request' param and the de-referenced one used in the invocation, so
// we'll only county times for those with structural equality.
func (calls callsSampleServiceDownloadResumable) TimesFor(request testext.SampleDownloadRequest) int {
	return calls.TimesMatching(func(actual testext.SampleDownloadRequest) bool {
		return actual == request
	})
}

// TimesMatching return the total number of times that DownloadResumable was invoked with any
// input that returns true when fed to your predicate function. It's a way to filter by
// requests that meet some requirement more complex than equality (like TimesFor uses).
func (calls callsSampleServiceDownloadResumable) TimesMatching(pred func(testext.SampleDownloadRequest) bool) int {
	count := 0
	for _, call := range calls {
		if pred(call.Request) {
			count++
		}
	}
	return count
}

/* ---- SampleService.Fail4XX Mock Support For  ---- */

func (mock *MockSampleService) Fail4XX(ctx context.Context, request *testext.SampleRequest) (*testext.SampleResponse, error) {
	mock.Calls.Fail4XX = mock.Calls.Fail4XX.invoked(*request)
	if mock.Fail4XXFunc == nil {
		return nil, fmt.Errorf("SampleService.Fail4XX not implemented")
	}
	response, err := mock.Fail4XXFunc(ctx, request)
	return response, err
}

type callSampleServiceFail4XX struct {
	Time    time.Time
	Request testext.SampleRequest
}

type callsSampleServiceFail4XX []callSampleServiceFail4XX

func (calls callsSampleServiceFail4XX) invoked(request testext.SampleRequest) callsSampleServiceFail4XX {
	return append(calls, callSampleServiceFail4XX{Time: time.Now(), Request: request})
}

// Times return the total number of times that Fail4XX was invoked with any request arguments.
func (calls callsSampleServiceFail4XX) Times() int {
	return len(calls)
}

// TimesFor return the total number of times that Fail4XX was invoked with the specific input. Equality
// is determined using == on this 'request' param and the de-referenced one used in the invocation, so
// we'll only county times for those with structural equality.
func (calls callsSampleServiceFail4XX) TimesFor(request testext.SampleRequest) int {
	return calls.TimesMatching(func(actual testext.SampleRequest) bool {
		return actual == request
	})
}

// TimesMatching return the total number of times that Fail4XX was invoked with any
// input that returns true when fed to your predicate function. It's a way to filter by
// requests that meet some requirement more complex than equality (like TimesFor uses).
func (calls callsSampleServiceFail4XX) TimesMatching(pred func(testext.SampleRequest) bool) int {
	count := 0
	for _, call := range calls {
		if pred(call.Request) {
			count++
		}
	}
	return count
}

/* ---- SampleService.Fail5XX Mock Support For  ---- */

func (mock *MockSampleService) Fail5XX(ctx context.Context, request *testext.SampleRequest) (*testext.SampleResponse, error) {
	mock.Calls.Fail5XX = mock.Calls.Fail5XX.invoked(*request)
	if mock.Fail5XXFunc == nil {
		return nil, fmt.Errorf("SampleService.Fail5XX not implemented")
	}
	response, err := mock.Fail5XXFunc(ctx, request)
	return response, err
}

type callSampleServiceFail5XX struct {
	Time    time.Time
	Request testext.SampleRequest
}

type callsSampleServiceFail5XX []callSampleServiceFail5XX

func (calls callsSampleServiceFail5XX) invoked(request testext.SampleRequest) callsSampleServiceFail5XX {
	return append(calls, callSampleServiceFail5XX{Time: time.Now(), Request: request})
}

// Times return the total number of times that Fail5XX was invoked with any request arguments.
func (calls callsSampleServiceFail5XX) Times() int {
	return len(calls)
}

// TimesFor return the total number of times that Fail5XX was invoked with the specific input. Equality
// is determined using == on this 'request' param and the de-referenced one used in the invocation, so
// we'll only county times for those with structural equality.
func (calls callsSampleServiceFail5XX) TimesFor(request testext.SampleRequest) int {
	return calls.TimesMatching(func(actual testext.SampleRequest) bool {
		return actual == request
	})
}

// TimesMatching return the total number of times that Fail5XX was invoked with any
// input that returns true when fed to your predicate function. It's a way to filter by
// requests that meet some requirement more complex than equality (like TimesFor uses).
func (calls callsSampleServiceFail5XX) TimesMatching(pred func(testext.SampleRequest) bool) int {
	count := 0
	for _, call := range calls {
		if pred(call.Request) {
			count++
		}
	}
	return count
}

/* ---- SampleService.ListenerA Mock Support For  ---- */

func (mock *MockSampleService) ListenerA(ctx context.Context, request *testext.SampleRequest) (*testext.SampleResponse, error) {
	mock.Calls.ListenerA = mock.Calls.ListenerA.invoked(*request)
	if mock.ListenerAFunc == nil {
		return nil, fmt.Errorf("SampleService.ListenerA not implemented")
	}
	response, err := mock.ListenerAFunc(ctx, request)
	return response, err
}

type callSampleServiceListenerA struct {
	Time    time.Time
	Request testext.SampleRequest
}

type callsSampleServiceListenerA []callSampleServiceListenerA

func (calls callsSampleServiceListenerA) invoked(request testext.SampleRequest) callsSampleServiceListenerA {
	return append(calls, callSampleServiceListenerA{Time: time.Now(), Request: request})
}

// Times return the total number of times that ListenerA was invoked with any request arguments.
func (calls callsSampleServiceListenerA) Times() int {
	return len(calls)
}

// TimesFor return the total number of times that ListenerA was invoked with the specific input. Equality
// is determined using == on this 'request' param and the de-referenced one used in the invocation, so
// we'll only county times for those with structural equality.
func (calls callsSampleServiceListenerA) TimesFor(request testext.SampleRequest) int {
	return calls.TimesMatching(func(actual testext.SampleRequest) bool {
		return actual == request
	})
}

// TimesMatching return the total number of times that ListenerA was invoked with any
// input that returns true when fed to your predicate function. It's a way to filter by
// requests that meet some requirement more complex than equality (like TimesFor uses).
func (calls callsSampleServiceListenerA) TimesMatching(pred func(testext.SampleRequest) bool) int {
	count := 0
	for _, call := range calls {
		if pred(call.Request) {
			count++
		}
	}
	return count
}

/* ---- SampleService.ListenerB Mock Support For  ---- */

func (mock *MockSampleService) ListenerB(ctx context.Context, request *testext.SampleRequest) (*testext.SampleResponse, error) {
	mock.Calls.ListenerB = mock.Calls.ListenerB.invoked(*request)
	if mock.ListenerBFunc == nil {
		return nil, fmt.Errorf("SampleService.ListenerB not implemented")
	}
	response, err := mock.ListenerBFunc(ctx, request)
	return response, err
}

type callSampleServiceListenerB struct {
	Time    time.Time
	Request testext.SampleRequest
}

type callsSampleServiceListenerB []callSampleServiceListenerB

func (calls callsSampleServiceListenerB) invoked(request testext.SampleRequest) callsSampleServiceListenerB {
	return append(calls, callSampleServiceListenerB{Time: time.Now(), Request: request})
}

// Times return the total number of times that ListenerB was invoked with any request arguments.
func (calls callsSampleServiceListenerB) Times() int {
	return len(calls)
}

// TimesFor return the total number of times that ListenerB was invoked with the specific input. Equality
// is determined using == on this 'request' param and the de-referenced one used in the invocation, so
// we'll only county times for those with structural equality.
func (calls callsSampleServiceListenerB) TimesFor(request testext.SampleRequest) int {
	return calls.TimesMatching(func(actual testext.SampleRequest) bool {
		return actual == request
	})
}

// TimesMatching return the total number of times that ListenerB was invoked with any
// input that returns true when fed to your predicate function. It's a way to filter by
// requests that meet some requirement more complex than equality (like TimesFor uses).
func (calls callsSampleServiceListenerB) TimesMatching(pred func(testext.SampleRequest) bool) int {
	count := 0
	for _, call := range calls {
		if pred(call.Request) {
			count++
		}
	}
	return count
}

/* ---- SampleService.OmitMe Mock Support For  ---- */

func (mock *MockSampleService) OmitMe(ctx context.Context, request *testext.SampleRequest) (*testext.SampleResponse, error) {
	mock.Calls.OmitMe = mock.Calls.OmitMe.invoked(*request)
	if mock.OmitMeFunc == nil {
		return nil, fmt.Errorf("SampleService.OmitMe not implemented")
	}
	response, err := mock.OmitMeFunc(ctx, request)
	return response, err
}

type callSampleServiceOmitMe struct {
	Time    time.Time
	Request testext.SampleRequest
}

type callsSampleServiceOmitMe []callSampleServiceOmitMe

func (calls callsSampleServiceOmitMe) invoked(request testext.SampleRequest) callsSampleServiceOmitMe {
	return append(calls, callSampleServiceOmitMe{Time: time.Now(), Request: request})
}

// Times return the total number of times that OmitMe was invoked with any request arguments.
func (calls callsSampleServiceOmitMe) Times() int {
	return len(calls)
}

// TimesFor return the total number of times that OmitMe was invoked with the specific input. Equality
// is determined using == on this 'request' param and the de-referenced one used in the invocation, so
// we'll only county times for those with structural equality.
func (calls callsSampleServiceOmitMe) TimesFor(request testext.SampleRequest) int {
	return calls.TimesMatching(func(actual testext.SampleRequest) bool {
		return actual == request
	})
}

// TimesMatching return the total number of times that OmitMe was invoked with any
// input that returns true when fed to your predicate function. It's a way to filter by
// requests that meet some requirement more complex than equality (like TimesFor uses).
func (calls callsSampleServiceOmitMe) TimesMatching(pred func(testext.SampleRequest) bool) int {
	count := 0
	for _, call := range calls {
		if pred(call.Request) {
			count++
		}
	}
	return count
}

/* ---- SampleService.Redirect Mock Support For  ---- */

func (mock *MockSampleService) Redirect(ctx context.Context, request *testext.SampleRedirectRequest) (*testext.SampleRedirectResponse, error) {
	mock.Calls.Redirect = mock.Calls.Redirect.invoked(*request)
	if mock.RedirectFunc == nil {
		return nil, fmt.Errorf("SampleService.Redirect not implemented")
	}
	response, err := mock.RedirectFunc(ctx, request)
	return response, err
}

type callSampleServiceRedirect struct {
	Time    time.Time
	Request testext.SampleRedirectRequest
}

type callsSampleServiceRedirect []callSampleServiceRedirect

func (calls callsSampleServiceRedirect) invoked(request testext.SampleRedirectRequest) callsSampleServiceRedirect {
	return append(calls, callSampleServiceRedirect{Time: time.Now(), Request: request})
}

// Times return the total number of times that Redirect was invoked with any request arguments.
func (calls callsSampleServiceRedirect) Times() int {
	return len(calls)
}

// TimesFor return the total number of times that Redirect was invoked with the specific input. Equality
// is determined using == on this 'request' param and the de-referenced one used in the invocation, so
// we'll only county times for those with structural equality.
func (calls callsSampleServiceRedirect) TimesFor(request testext.SampleRedirectRequest) int {
	return calls.TimesMatching(func(actual testext.SampleRedirectRequest) bool {
		return actual == request
	})
}

// TimesMatching return the total number of times that Redirect was invoked with any
// input that returns true when fed to your predicate function. It's a way to filter by
// requests that meet some requirement more complex than equality (like TimesFor uses).
func (calls callsSampleServiceRedirect) TimesMatching(pred func(testext.SampleRedirectRequest) bool) int {
	count := 0
	for _, call := range calls {
		if pred(call.Request) {
			count++
		}
	}
	return count
}

/* ---- SampleService.SecureWithRoles Mock Support For  ---- */

func (mock *MockSampleService) SecureWithRoles(ctx context.Context, request *testext.SampleSecurityRequest) (*testext.SampleSecurityResponse, error) {
	mock.Calls.SecureWithRoles = mock.Calls.SecureWithRoles.invoked(*request)
	if mock.SecureWithRolesFunc == nil {
		return nil, fmt.Errorf("SampleService.SecureWithRoles not implemented")
	}
	response, err := mock.SecureWithRolesFunc(ctx, request)
	return response, err
}

type callSampleServiceSecureWithRoles struct {
	Time    time.Time
	Request testext.SampleSecurityRequest
}

type callsSampleServiceSecureWithRoles []callSampleServiceSecureWithRoles

func (calls callsSampleServiceSecureWithRoles) invoked(request testext.SampleSecurityRequest) callsSampleServiceSecureWithRoles {
	return append(calls, callSampleServiceSecureWithRoles{Time: time.Now(), Request: request})
}

// Times return the total number of times that SecureWithRoles was invoked with any request arguments.
func (calls callsSampleServiceSecureWithRoles) Times() int {
	return len(calls)
}

// TimesFor return the total number of times that SecureWithRoles was invoked with the specific input. Equality
// is determined using == on this 'request' param and the de-referenced one used in the invocation, so
// we'll only county times for those with structural equality.
func (calls callsSampleServiceSecureWithRoles) TimesFor(request testext.SampleSecurityRequest) int {
	return calls.TimesMatching(func(actual testext.SampleSecurityRequest) bool {
		return actual == request
	})
}

// TimesMatching return the total number of times that SecureWithRoles was invoked with any
// input that returns true when fed to your predicate function. It's a way to filter by
// requests that meet some requirement more complex than equality (like TimesFor uses).
func (calls callsSampleServiceSecureWithRoles) TimesMatching(pred func(testext.SampleSecurityRequest) bool) int {
	count := 0
	for _, call := range calls {
		if pred(call.Request) {
			count++
		}
	}
	return count
}

/* ---- SampleService.Sleep Mock Support For  ---- */

func (mock *MockSampleService) Sleep(ctx context.Context, request *testext.SampleRequest) (*testext.SampleResponse, error) {
	mock.Calls.Sleep = mock.Calls.Sleep.invoked(*request)
	if mock.SleepFunc == nil {
		return nil, fmt.Errorf("SampleService.Sleep not implemented")
	}
	response, err := mock.SleepFunc(ctx, request)
	return response, err
}

type callSampleServiceSleep struct {
	Time    time.Time
	Request testext.SampleRequest
}

type callsSampleServiceSleep []callSampleServiceSleep

func (calls callsSampleServiceSleep) invoked(request testext.SampleRequest) callsSampleServiceSleep {
	return append(calls, callSampleServiceSleep{Time: time.Now(), Request: request})
}

// Times return the total number of times that Sleep was invoked with any request arguments.
func (calls callsSampleServiceSleep) Times() int {
	return len(calls)
}

// TimesFor return the total number of times that Sleep was invoked with the specific input. Equality
// is determined using == on this 'request' param and the de-referenced one used in the invocation, so
// we'll only county times for those with structural equality.
func (calls callsSampleServiceSleep) TimesFor(request testext.SampleRequest) int {
	return calls.TimesMatching(func(actual testext.SampleRequest) bool {
		return actual == request
	})
}

// TimesMatching return the total number of times that Sleep was invoked with any
// input that returns true when fed to your predicate function. It's a way to filter by
// requests that meet some requirement more complex than equality (like TimesFor uses).
func (calls callsSampleServiceSleep) TimesMatching(pred func(testext.SampleRequest) bool) int {
	count := 0
	for _, call := range calls {
		if pred(call.Request) {
			count++
		}
	}
	return count
}

/* ---- SampleService.TriggerFailure Mock Support For  ---- */

func (mock *MockSampleService) TriggerFailure(ctx context.Context, request *testext.SampleRequest) (*testext.SampleResponse, error) {
	mock.Calls.TriggerFailure = mock.Calls.TriggerFailure.invoked(*request)
	if mock.TriggerFailureFunc == nil {
		return nil, fmt.Errorf("SampleService.TriggerFailure not implemented")
	}
	response, err := mock.TriggerFailureFunc(ctx, request)
	return response, err
}

type callSampleServiceTriggerFailure struct {
	Time    time.Time
	Request testext.SampleRequest
}

type callsSampleServiceTriggerFailure []callSampleServiceTriggerFailure

func (calls callsSampleServiceTriggerFailure) invoked(request testext.SampleRequest) callsSampleServiceTriggerFailure {
	return append(calls, callSampleServiceTriggerFailure{Time: time.Now(), Request: request})
}

// Times return the total number of times that TriggerFailure was invoked with any request arguments.
func (calls callsSampleServiceTriggerFailure) Times() int {
	return len(calls)
}

// TimesFor return the total number of times that TriggerFailure was invoked with the specific input. Equality
// is determined using == on this 'request' param and the de-referenced one used in the invocation, so
// we'll only county times for those with structural equality.
func (calls callsSampleServiceTriggerFailure) TimesFor(request testext.SampleRequest) int {
	return calls.TimesMatching(func(actual testext.SampleRequest) bool {
		return actual == request
	})
}

// TimesMatching return the total number of times that TriggerFailure was invoked with any
// input that returns true when fed to your predicate function. It's a way to filter by
// requests that meet some requirement more complex than equality (like TimesFor uses).
func (calls callsSampleServiceTriggerFailure) TimesMatching(pred func(testext.SampleRequest) bool) int {
	count := 0
	for _, call := range calls {
		if pred(call.Request) {
			count++
		}
	}
	return count
}

/* ---- SampleService.TriggerLowerCase Mock Support For  ---- */

func (mock *MockSampleService) TriggerLowerCase(ctx context.Context, request *testext.SampleRequest) (*testext.SampleResponse, error) {
	mock.Calls.TriggerLowerCase = mock.Calls.TriggerLowerCase.invoked(*request)
	if mock.TriggerLowerCaseFunc == nil {
		return nil, fmt.Errorf("SampleService.TriggerLowerCase not implemented")
	}
	response, err := mock.TriggerLowerCaseFunc(ctx, request)
	return response, err
}

type callSampleServiceTriggerLowerCase struct {
	Time    time.Time
	Request testext.SampleRequest
}

type callsSampleServiceTriggerLowerCase []callSampleServiceTriggerLowerCase

func (calls callsSampleServiceTriggerLowerCase) invoked(request testext.SampleRequest) callsSampleServiceTriggerLowerCase {
	return append(calls, callSampleServiceTriggerLowerCase{Time: time.Now(), Request: request})
}

// Times return the total number of times that TriggerLowerCase was invoked with any request arguments.
func (calls callsSampleServiceTriggerLowerCase) Times() int {
	return len(calls)
}

// TimesFor return the total number of times that TriggerLowerCase was invoked with the specific input. Equality
// is determined using == on this 'request' param and the de-referenced one used in the invocation, so
// we'll only county times for those with structural equality.
func (calls callsSampleServiceTriggerLowerCase) TimesFor(request testext.SampleRequest) int {
	return calls.TimesMatching(func(actual testext.SampleRequest) bool {
		return actual == request
	})
}

// TimesMatching return the total number of times that TriggerLowerCase was invoked with any
// input that returns true when fed to your predicate function. It's a way to filter by
// requests that meet some requirement more complex than equality (like TimesFor uses).
func (calls callsSampleServiceTriggerLowerCase) TimesMatching(pred func(testext.SampleRequest) bool) int {
	count := 0
	for _, call := range calls {
		if pred(call.Request) {
			count++
		}
	}
	return count
}

/* ---- SampleService.TriggerUpperCase Mock Support For  ---- */

func (mock *MockSampleService) TriggerUpperCase(ctx context.Context, request *testext.SampleRequest) (*testext.SampleResponse, error) {
	mock.Calls.TriggerUpperCase = mock.Calls.TriggerUpperCase.invoked(*request)
	if mock.TriggerUpperCaseFunc == nil {
		return nil, fmt.Errorf("SampleService.TriggerUpperCase not implemented")
	}
	response, err := mock.TriggerUpperCaseFunc(ctx, request)
	return response, err
}

type callSampleServiceTriggerUpperCase struct {
	Time    time.Time
	Request testext.SampleRequest
}

type callsSampleServiceTriggerUpperCase []callSampleServiceTriggerUpperCase

func (calls callsSampleServiceTriggerUpperCase) invoked(request testext.SampleRequest) callsSampleServiceTriggerUpperCase {
	return append(calls, callSampleServiceTriggerUpperCase{Time: time.Now(), Request: request})
}

// Times return the total number of times that TriggerUpperCase was invoked with any request arguments.
func (calls callsSampleServiceTriggerUpperCase) Times() int {
	return len(calls)
}

// TimesFor return the total number of times that TriggerUpperCase was invoked with the specific input. Equality
// is determined using == on this 'request' param and the de-referenced one used in the invocation, so
// we'll only county times for those with structural equality.
func (calls callsSampleServiceTriggerUpperCase) TimesFor(request testext.SampleRequest) int {
	return calls.TimesMatching(func(actual testext.SampleRequest) bool {
		return actual == request
	})
}

// TimesMatching return the total number of times that TriggerUpperCase was invoked with any
// input that returns true when fed to your predicate function. It's a way to filter by
// requests that meet some requirement more complex than equality (like TimesFor uses).
func (calls callsSampleServiceTriggerUpperCase) TimesMatching(pred func(testext.SampleRequest) bool) int {
	count := 0
	for _, call := range calls {
		if pred(call.Request) {
			count++
		}
	}
	return count
}
